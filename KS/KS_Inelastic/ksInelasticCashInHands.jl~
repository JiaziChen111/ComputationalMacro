using LinearAlgebra
using Parameters
using IterativeSolvers
using Plots
using BenchmarkTools
using FastGaussQuadrature
using BenchmarkTools
using ForwardDiff
using QuantEcon
using GLM
using Calculus

################################### Model types #########################

struct ModelParameters{R <: Real}
    β::R
    d::R
    B_::R
    γc::R
    γl::R
    α::R
    ζ::R
    homeY::R
    hfix::R
end

struct ModelFiniteElement{R <: Real,I <: Integer}
    elements::Array{R,2}
    elementsID::Array{I,2}
    zGrid::Array{R,1}
    KGrid::Array{R,1}
    m::I
    wx::Array{R,1}
    ax::Array{R,1}
    nz::I
    nK::I
    ne::I
end

struct ModelMarkovChain{R <: Real,I <: Integer}
    states::Array{R,2}
    statesID::Array{I,2}
    aggstatesID::Array{I,1}
    ns::I #number of states
    nis::I #number of individual states
    nas::I #number of aggregate state
    πz::Array{R,2} #aggregate transition
    Π::Array{R,2}
    IndStates::Array{R,1}
    AggStates::Array{R,1}
    LoML::Array{R,1}
end

struct ModelDistribution{R <: Real,I <: Integer}
    DistributionSize::I
    DistributionAssetGrid::Array{R,1}
    InitialDistribution::Array{R,2}
    AggShocks::Array{I,1}
    TimePeriods::I
end


struct KSMarkovianFiniteElement{R <: Real,I <: Integer}
    Guess::Array{R,1}
    GuessM::Array{R,2}
    LoMK::Array{R,2}    
    Parameters::ModelParameters{R}
    FiniteElement::ModelFiniteElement{R,I}
    MarkovChain::ModelMarkovChain{R,I}
    Distribution::ModelDistribution{R,I}
end



#Include ayiagari functions and types
#include("ks.jl")

"""
Construct and Ayiagari model instace of all parts needed to solve the model
"""
function KSModel(
    UnempDurG::R = 1.5,
    UnempDurB::R = 2.5,
    Corr::R = 0.25,
    UnempG::R = 0.04,
    UnempB::R = 0.1,
    DurZG::R = 8.0,
    DurZB::R = 8.0,
    hfix::R = 0.3271,
    homeY::R=0.07,
    gZ::R = 1.01,
    bZ::R = 0.99,
    empS::R = 1.0,
    unempS::R = 0.0,
    β::R = 0.99,
    d::R = 0.025,
    γc::R = 1.0,
    γl::R = 1.0,
    α::R = 0.36,
    ζ::R = 1000000000.0,
    B_::R = 0.0,
    Kg1::R =0.095,
    Kg2::R =0.962,
    Kb1::R =0.085,
    Kb2::R =0.965,
    nz::I = 50,  #asset grid size
    zMax::R = 100.0, #uppper bound on capital
    nK::I = 8,  #aggregate capital grid size
    KMax::R = 12.0,  #upper bound on aggregate capital
    KMin::R = 10.0, #lower bound on aggregate capital
    NumberOfHouseholds::I = 800,
    TimePeriods::I = 15000,
    DroppedPeriods::I = 3000,
    DistributionUL::R = 100.0,
    NumberOfQuadratureNodesPerElement::I = 2
) where{R <: Real,I <: Integer}

    ###################################################
    ################   Stochastic process #############
    ###################################################
    # unemployment rates depend only on the aggregate productivity shock
    Unemp = [UnempG;UnempB]
    
    # probability of remaining in 'Good/High' productivity state
    πzg = 1.0 - 1.0/DurZG
    
    # probability of remaining in the 'Bad/Low' productivity state
    πzb = 1.0 - 1.0/DurZB
    
    # matrix of transition probabilities for aggregate state
    πz = [πzg 1.0-πzg;
          1.0-πzb πzb]
    
    # transition probabilities between employment states when aggregate productivity is high
    p22 = 1.0 - 1.0 / UnempDurG
    p21 = 1.0 - p22
    p11 = (((1.0 - UnempG) - UnempG * p21) / (1.0 - UnempG))
    #       e    u   for good to good
    P11 = [p11 1.0-p11; 
           p21 p22]
    
    # transition probabilities between employment states when aggregate productivity is low
    p22 = 1.0 - 1.0 / UnempDurB
    p21 = 1.0 - p22
    p11 = (((1.0 - UnempB) - UnempB * p21) / (1.0 - UnempB))
    #       e    u   for bad to bad
    P00 = [p11 1.0-p11; 
           p21 p22] 
    
    # transition probabilities between employment states when aggregate productivity is high
    p22 = (1.0 + Corr) * p22
    p21 = 1.0 - p22
    p11 = (((1.0 - UnempB) - UnempG * p21) / 
           (1.0 - UnempG))
    #       e    u   for good to bad
    P10 = [p11 1.0-p11; 
           p21 p22]

    p22 = (1.0 - Corr) * (1.0 - 1.0 / UnempDurG)
    p21 = 1.0 - p22
    p11 = (((1.0 - UnempG) - UnempB * p21) / 
           (1.0 - UnempB))
    #       e    u   for bad to good
    P01 = [p11 1.0-p11; 
           p21 p22]

    P = [πz[1,1]*P11 πz[1,2]*P10;
         πz[2,1]*P01 πz[2,2]*P00]
    
    #states = [1.01 1.0;1.01 0.1;0.99 1.0;0.99 0.1]
    states = [1.01 1.0;1.01 0.0;0.99 1.0;0.99 0.0] #krusell
    statesID = [1 1;1 2;2 1; 2 2]
    aggstatesID = [1;1;2;2]
    ns = size(states,1)

    LoMK = [Kg1 Kg2;
            Kb1 Kb2]
    #aggL = [0.3271*(1.0-UnempG);0.3271*(1.0-UnempB)]
    LoML = [hfix*(1.0-UnempG);
            hfix*(1.0-UnempB)]
    nis,nas = 2,2
    KSMarkovChain = ModelMarkovChain(states,statesID,aggstatesID,ns,nis,nas,πz,P,[empS;unempS],[gZ;bZ],LoML)
    

    ##########################################################
    ############### Mesh generation ##########################
    ##########################################################
    function grid_fun(a_min,a_max,na, pexp)
        x = range(a_min,step=0.5,length=na)
        grid = a_min .+ (a_max-a_min)*(x.^pexp/maximum(x.^pexp))
        return grid
    end
    #zGrid = grid_fun(homeY,zMax,nz,4)
    zGrid = collect(linspace(homeY^(1/30), zMax^(1/30), nz).^30)
    #kGrid = collect(range(0.0,stop = KMax,length=nk))
    KGrid = collect(range(KMin,stop = KMax,length=nK))
    #LGrid = range(LMin,stop = LMax,length=nL)
    nzK = nz*nK

    ne = (nz-1)*(nK-1)               #number of elements
    nv = 4                                  #number of values by element (k1,k2,K1,K2,L1,L2)
    
    ElementsID = zeros(I,ne,nv) #element indices
    Elements = zeros(R,ne,nv) #elements

    #Build finite element mesh with node indices (k1,k2,K1,K2,L1,L2) per element
    for zi = 1:nz-1 #across ind k
        for Ki = 1:nK-1 #across agg L
            n = (zi-1)*(nK-1) + Ki  
            ElementsID[n,1],ElementsID[n,2] = zi,zi+1
            ElementsID[n,3],ElementsID[n,4] = Ki,Ki+1
            Elements[n,1],Elements[n,2] = zGrid[zi],zGrid[zi+1]
            Elements[n,3],Elements[n,4] = KGrid[Ki],KGrid[Ki+1]
        end
    end
    QuadratureAbscissas,QuadratureWeights = gausslegendre(NumberOfQuadratureNodesPerElement)
    #QuadratureAbscissasAgg,QuadratureWeightsAgg = gausslegendre(NumberOfQuadratureNodesPerElementAgg)

    KSFiniteElement = ModelFiniteElement(Elements,ElementsID,zGrid,KGrid,NumberOfQuadratureNodesPerElement,QuadratureWeights,QuadratureAbscissas,nz,nK,ne)

    #Construct a guess
    Guess = zeros(R,nzK*ns)
    for s=1:ns
        A,ϵ = states[s,1],states[s,2]
        L = LoML[aggstatesID[s]] 
        for (zi,z) in enumerate(zGrid) #ind k
            for (Ki,K) in enumerate(KGrid) #agg k
                n = (s-1)*nzK + (zi-1)*nK + Ki
                Guess[n] = 0.98*z  
            end
        end
    end
    GuessM = reshape(Guess,nzK,ns)

    ################### Distribution pieces
    #Grid on distribution
    DistributionAssetGrid = collect(range(0.0,stop = DistributionUL,length = NumberOfHouseholds))

#choose uniform distribution

    InitialDistribution = rand(nis*NumberOfHouseholds)
    InitialDistribution = InitialDistribution/sum(InitialDistribution)
    InitialDistribution = reshape(InitialDistribution,NumberOfHouseholds,nis)

#simulate time series
    mc = MarkovChain(πz, [1, 2])
    AggShocks = simulate(mc,TimePeriods,init=1)

    #Define KS distribution object
    KSDistribution = ModelDistribution(NumberOfHouseholds,DistributionAssetGrid,InitialDistribution,AggShocks,TimePeriods)

    KSParameters = ModelParameters(β,d,B_,γc,γl,α,ζ,homeY,hfix)
    
    KSMarkovianFiniteElement(Guess,GuessM,LoMK,KSParameters,KSFiniteElement,KSMarkovChain,KSDistribution)
end





function WeightedResidual(
    θ::Array{F,1},
    LoMK::Array{R,2},
    FiniteElementObj::KSMarkovianFiniteElement{R,I}) where{R <: Real,I <: Integer,F <: Real}

    #Model parameters
    #@unpack β,α,δ,μ,σ,ρ,ζ,Uc,Ucc = FiniteElementObj.Parameters
    @unpack β,d,B_,γc,γl,α,ζ,homeY,hfix = FiniteElementObj.Parameters  
    @unpack elements,elementsID,zGrid,KGrid,m,wx,ax,nz,nK,ne = FiniteElementObj.FiniteElement  
    @unpack states,IndStates,AggStates,statesID,aggstatesID,ns,nis,nas,πz,Π,LoML = FiniteElementObj.MarkovChain  
    l,c,uc,ucc,ul,ull,∂c∂a,∂c∂l,∂l∂ai,∂c∂ai,∂l∂aj,∂c∂aj = 0.5,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0
    lp,cp,ucp,uccp,ulp,ullp,∂cp∂ap = 0.5,0.0,0.0,0.0,0.0,0.0,0.0
    
    nkp = 0
    np = 0    
    
    #Dimension of the problem
    nzK = nz*nK
    nx = ns*nzK
    mz,mK = m,m
    Res  = zeros(F,nx) 
    dr = zeros(F,nx,nx)
    for s = 1:ns #for each state in the state space
        A,ϵ = states[s,1],states[s,2]
        L = LoML[aggstatesID[s]] 
        Kb0,Kb1 = LoMK[aggstatesID[s],1], LoMK[aggstatesID[s],2] 
        for n=1:ne #for each element in the finite element mesh
            z1,z2 = elements[n,1],elements[n,2]
            K1,K2 = elements[n,3],elements[n,4]
            zi,Ki = elementsID[n,1],elementsID[n,3] #indices of endog states for policy

            ### NOTE: these indices keep track of which elements solution depends on
            s1,s4 = (s-1)*nzK + (zi-1)*nK + Ki, (s-1)*nzK + (zi-1)*nK + Ki + 1
            s2,s3 = (s-1)*nzK + zi*nK + Ki, (s-1)*nzK + zi*nK + Ki + 1
            for mzi = 1:mz #integrate across k
                z = (z1 + z2)/2.0 + (z2 - z1)/2.0 * ax[mzi] #use Legendre's rule
                #k = (ax[mki]+1.0)*(k2-k1)/2.0 + k2
                wz = (z2-z1)/2.0*wx[mzi]
                for mKi = 1:mK #integrate across k̄
                    K = (K1 + K2)/2.0 + (K2 - K1)/2.0 * ax[mKi] #use Legendre's rule
                    #K = (ax[mKi]+1.0)*(K2-K1)/2.0 + K2
                    wK = (K2-K1)/2.0*wx[mKi]
                    #Kv = (K2-K1)/2.0*wx[mKi]/((k2-k1)*(K2-K1))
                    #Get functions of agg variables
                    #r = α*A*(K/L)^(α-1.0) - d 
                    #w = (1.0-α)*A*(K/L)^α

                    #Form basis for piecewise function
                    basis1 = (z2 - z)/(z2 - z1) * (K2 - K)/(K2 - K1)
                    basis2 = (z - z1)/(z2 - z1) * (K2 - K)/(K2 - K1)
                    basis3 = (z - z1)/(z2 - z1) * (K - K1)/(K2 - K1)
                    basis4 = (z2 - z)/(z2 - z1) * (K - K1)/(K2 - K1)
                  
                    #Policy functions 
                    kp = θ[s1]*basis1 + θ[s2]*basis2 + 
                             θ[s3]*basis3 + θ[s4]*basis4

                    pen = ζ*min(kp,B_)^2
                    dpen = 2.0*ζ*min(kp,B_)                    
                    
                    c = z - kp
                    if γc == 1.0
                        uc = 1.0/c
                        ucc =-1.0/(c^2.0)
                    else
                        uc = c^(-γc)
                        ucc = -γc*c^(-γc - 1.0)                    
                    end
                    ∂c∂ki = -1.0

                    #Update state variables for next period
                    Kp = exp(Kb0 + Kb1*log(K))
                    
                    tsai = 0.0
                    sum1 = 0.0 
                    for sp = 1:ns                                             #Find the element it belongs to
                        Ap,ϵp = states[sp,1],states[sp,2]
                        Lp = LoML[aggstatesID[sp]]

                        rp = α*Ap*(Kp/Lp)^(α-1.0) - d
                        wp = (1.0-α)*Ap*(Kp/Lp)^α

                        #Update cash in hands
                        zp = wp*ϵp*hfix + homeY*(1.0 - ϵp) + (1.0 + rp)*kp - rp*B_
                        
                        for i = 1:ne
                            if (zp>=elements[i,1] && zp<=elements[i,2]) 
                                nkp = i     
                                break
                            elseif zp<elements[1,1]
                                nkp = 1
                                break
                            else
                                nkp = ne-nz
                            end
                        end
                        # Find the aggregate state and adjust if it falls outside the grid
                        for j = nkp:nkp+nK-2
                            if (Kp >= elements[j,3] && Kp <= elements[j,4]) 
                                np = j     
                                break
                            elseif Kp < elements[nkp,3]
                                np = nkp
                                break
                            else
                                np = nkp+nK-2
                            end
                        end

                        zp1,zp2 = elements[np,1],elements[np,2]
                        Kp1,Kp2 = elements[np,3],elements[np,4]
                        zpi,Kpi = elementsID[np,1],elementsID[np,3] #indices of endog states for policy

                        basisp1 = (zp2 - zp)/(zp2 - zp1) * (Kp2 - Kp)/(Kp2 - Kp1)
                        basisp2 = (zp - zp1)/(zp2 - zp1) * (Kp2 - Kp)/(Kp2 - Kp1)
                        basisp3 = (zp - zp1)/(zp2 - zp1) * (Kp - Kp1)/(Kp2 - Kp1)
                        basisp4 = (zp2 - zp)/(zp2 - zp1) * (Kp - Kp1)/(Kp2 - Kp1)

                        ####### Store derivatives###############
                        ∂zp∂ki = 1.0 + rp
                        dbasisp1 = -∂zp∂ki/(zp2 - zp1) * (Kp2 - Kp)/(Kp2 - Kp1) 
                        dbasisp2 =  ∂zp∂ki/(zp2 - zp1) * (Kp2 - Kp)/(Kp2 - Kp1)
                        dbasisp3 =  ∂zp∂ki/(zp2 - zp1) * (Kp - Kp1)/(Kp2 - Kp1)
                        dbasisp4 = -∂zp∂ki/(zp2 - zp1) * (Kp - Kp1)/(Kp2 - Kp1)

                        sp1,sp4 = (sp-1)*nzK + (zpi-1)*nK + Kpi, (sp-1)*nzK + (zpi-1)*nK + Kpi + 1
                        sp2,sp3 = (sp-1)*nzK + zpi*nK + Kpi, (sp-1)*nzK + zpi*nK + Kpi + 1

                        #Policy functions
                        kpp = θ[sp1]*basisp1 + θ[sp2]*basisp2 + 
                                  θ[sp3]*basisp3 + θ[sp4]*basisp4

                        cp = zp - kpp

                        if γc == 1.0
                            ucp = 1.0/cp
                            uccp =-1.0/cp^2.0
                        else
                            ucp = cp^(-γc)
                            uccp = -γc*cp^(-γc - 1.0)                    
                        end
                        
                         
                        ∂kpp∂ki = θ[sp1]*dbasisp1 + θ[sp2]*dbasisp2 +
                            θ[sp3]*dbasisp3 + θ[sp4]*dbasisp4
                        ∂cp∂ki = ∂zp∂ki - ∂kpp∂ki 
                        ∂cp∂kj = -1.0
                        sum1 += β*Π[s,sp]*(1.0 + rp)*ucp + pen
                        #sum1 = 0.0
                        #derivatives of kp have θi associated with kp
                        tsai += β*Π[s,sp]*(1.0 + rp)*uccp*∂cp∂ki + dpen
                        #tsai = 0.0
                        #derivatives of kpp wrt kp have θj associated with kpp
                        tsaj = β*Π[s,sp]*(1.0 + rp)*uccp*∂cp∂kj 
                        #tsaj = 0.0
                        dr[s1,sp1] +=  basis1 * wz * wK * tsaj * basisp1
                        dr[s1,sp2] +=  basis1 * wz * wK * tsaj * basisp2
                        dr[s1,sp3] +=  basis1 * wz * wK * tsaj * basisp3
                        dr[s1,sp4] +=  basis1 * wz * wK * tsaj * basisp4
                        dr[s2,sp1] +=  basis2 * wz * wK * tsaj * basisp1
                        dr[s2,sp2] +=  basis2 * wz * wK * tsaj * basisp2
                        dr[s2,sp3] +=  basis2 * wz * wK * tsaj * basisp3
                        dr[s2,sp4] +=  basis2 * wz * wK * tsaj * basisp4
                        dr[s3,sp1] +=  basis3 * wz * wK * tsaj * basisp1
                        dr[s3,sp2] +=  basis3 * wz * wK * tsaj * basisp2
                        dr[s3,sp3] +=  basis3 * wz * wK * tsaj * basisp3
                        dr[s3,sp4] +=  basis3 * wz * wK * tsaj * basisp4
                        dr[s4,sp1] +=  basis4 * wz * wK * tsaj * basisp1
                        dr[s4,sp2] +=  basis4 * wz * wK * tsaj * basisp2
                        dr[s4,sp3] +=  basis4 * wz * wK * tsaj * basisp3
                        dr[s4,sp4] +=  basis4 * wz * wK * tsaj * basisp4

                    end 
                    #add the LHS and RHS of euler for each s wrt to θi
 
                    dres =  tsai - ucc*∂c∂ki

                    dr[s1,s1] +=  basis1 * wz * wK * dres * basis1
                    dr[s1,s2] +=  basis1 * wz * wK * dres * basis2
                    dr[s1,s3] +=  basis1 * wz * wK * dres * basis3
                    dr[s1,s4] +=  basis1 * wz * wK * dres * basis4
                    dr[s2,s1] +=  basis2 * wz * wK * dres * basis1
                    dr[s2,s2] +=  basis2 * wz * wK * dres * basis2
                    dr[s2,s3] +=  basis2 * wz * wK * dres * basis3
                    dr[s2,s4] +=  basis2 * wz * wK * dres * basis4
                    dr[s3,s1] +=  basis3 * wz * wK * dres * basis1
                    dr[s3,s2] +=  basis3 * wz * wK * dres * basis2
                    dr[s3,s3] +=  basis3 * wz * wK * dres * basis3
                    dr[s3,s4] +=  basis3 * wz * wK * dres * basis4
                    dr[s4,s1] +=  basis4 * wz * wK * dres * basis1
                    dr[s4,s2] +=  basis4 * wz * wK * dres * basis2
                    dr[s4,s3] +=  basis4 * wz * wK * dres * basis3
                    dr[s4,s4] +=  basis4 * wz * wK * dres * basis4

                    res = sum1 - uc
                    Res[s1] += basis1 * wz * wK * res
                    Res[s2] += basis2 * wz * wK * res  
                    Res[s3] += basis3 * wz * wK * res 
                    Res[s4] += basis4 * wz * wK * res 
                end
            end
        end
    end
   Res,dr
end


############################some derivative trials
#KS = KSModel()
#res, resJ = WeightedResidual(KS.Guess,KS.LoMK,KS)
#gradj = ForwardDiff.jacobian(t -> WeightedResidual(t,KS.LoMK,KS)[1],KS.Guess)
#LinearAlgebra.norm(resJ - gradj,Inf)


function SolveFiniteElement(
    guess::Array{R,1},
    LoMK::Array{R,2},
    FiniteElementObj::KSMarkovianFiniteElement{R,I},
    maxn::Int64 = 700,
    tol = 1e-10
) where{R <: Real,I <: Integer}

    nz =  FiniteElementObj.FiniteElement.nz
    nK = FiniteElementObj.FiniteElement.nK
    ns = FiniteElementObj.MarkovChain.ns
    nx = nz*nK*ns
    kink = Integer[]
    converged = false
    θ = guess
    #Newton Iteration
    for i = 1:maxn
        Res,dRes = WeightedResidual(θ,LoMK,FiniteElementObj)
        #dRes = ForwardDiff.jacobian(t -> WeightedResidual(t,LoMK,FiniteElementObj)[1],θ)
        #@show LinearAlgebra.norm(dRes - dRes2,Inf)
        step = - dRes \ Res
        if LinearAlgebra.norm(step) > 1.0
            θ += 1.0/10.0*step
        else
            θ += 1.0/1.0*step
        end
        @show LinearAlgebra.norm(step)
        if LinearAlgebra.norm(step) < tol
            converged = true
            for i = 1:nx
                if θ[i] < 0.0
                    push!(kink,i)
                end
            end
            break
        end
    end
    #=if converged == false
        return error("first step did not converge")
    end
    @show kink
    ###Eliminate kink
    for j = 1:maxn
        Res,dRes = WeightedResidual(θ,LoMK,FiniteElementObj)
        for k in kink
            for ii =1:nx
                dRes[k,ii] = 0.0
                dRes[ii,k] = 0.0
                dRes[k,k] = 1.0
                Res[k] = θ[k]
            end
        end
        #@show Res
        step = - dRes \ Res
        if LinearAlgebra.norm(step) > 1.0
            θ += 1.0/10.0*step
        else
            θ += 1.0/1.0*step
        end
        @show LinearAlgebra.norm(step)
        if LinearAlgebra.norm(step) < tol
            return θ
            break     
        end
    end =#
    return θ
end

function NextPeriodDistribution(
    Φ::Array{R,2},
    LoMK::Array{R,2},
    AggStateToday::I,
    AggStateTomorrow::I,
    θ::Array{F,1},
    FiniteElementObj::KSMarkovianFiniteElement{R,I},
    statdist = false) where{R <: Real,I <: Integer,F <: Real}

    @unpack β,d,B_,γc,γl,α,ζ,homeY,hfix = FiniteElementObj.Parameters  
    @unpack elements,elementsID,zGrid,KGrid,nz,nK,ne = FiniteElementObj.FiniteElement  
    @unpack states,IndStates,AggStates,statesID,aggstatesID,ns,nis,nas,πz,Π,LoML =FiniteElementObj.MarkovChain 
    @unpack DistributionSize,DistributionAssetGrid,InitialDistribution,AggShocks,TimePeriods = FiniteElementObj.Distribution

    nzK = nz*nK

    
    K = sum(Φ[:,1] .* DistributionAssetGrid) + sum(Φ[:,2] .* DistributionAssetGrid)
    L = LoML[AggStateToday]
    A = states[aggstatesID[AggStateToday],1]
    r = α*A*(K/L)^(α-1.0) - d 
    w = (1.0-α)*A*(K/L)^α

    state  = ifelse(AggStateToday == 1, [1,2], [3,4])
    statep = ifelse(AggStateTomorrow == 1, [1,2], [3,4])
    Πz = Π[state,statep]
    nki=0
    n=0

    Φp = fill(0.0,size(Φ))
    for (is,ϵ) = enumerate(IndStates)
        (is == 1 && AggStateToday == 1) ? s = 1 :
            (is == 2 && AggStateToday == 1) ? s = 2 :
                (is == 1 && AggStateToday == 2) ? s = 3 : s = 4
        for (ki,k) in enumerate(DistributionAssetGrid)
            #Get implied cash in hands
            z = w*ϵ*hfix + homeY*(1.0 - ϵ) + (1.0 + r)*k - r*B_
            for i = 1:ne
                if (z>=elements[i,1] && z<=elements[i,2]) 
                    nki = i     
                    break
                elseif z<elements[1,1]
                    nki = 1
                    break
                else
                    nki = ne-nz
                end
            end
            # Find the aggregate state and adjust if it falls outside the grid
            for j = nki:nki+nK-2
                if (K >= elements[j,3] && K <= elements[j,4]) 
                    n = j     
                    break
                elseif K < elements[nki,3]
                    n = nki
                    break
                else
                    n = nki+nK-2
                end
            end
            z1,z2 = elements[n,1],elements[n,2]
            K1,K2 = elements[n,3],elements[n,4]
            zii,Ki = elementsID[n,1],elementsID[n,3] #indices of endog states for policy
            s1,s4 = (s-1)*nzK + (zii-1)*nK + Ki, (s-1)*nzK + (zii-1)*nK + Ki + 1
            s2,s3 = (s-1)*nzK + zii*nK + Ki, (s-1)*nzK + zii*nK + Ki + 1

            basis1 = (z2 - z)/(z2 - z1) * (K2 - K)/(K2 - K1)
            basis2 = (z - z1)/(z2 - z1) * (K2 - K)/(K2 - K1)
            basis3 = (z - z1)/(z2 - z1) * (K - K1)/(K2 - K1)
            basis4 = (z2 - z)/(z2 - z1) * (K - K1)/(K2 - K1)

            #Policy functions 
            kp = θ[s1]*basis1 + θ[s2]*basis2 + θ[s3]*basis3 + θ[s4]*basis4
            np = searchsortedlast(DistributionAssetGrid,kp)
            if (np > 0) && (np < DistributionSize)
                h1 = DistributionAssetGrid[np]
                h2 = DistributionAssetGrid[np+1]
            end

            
            Πtot = Πz[is,1]+Πz[is,2]
            if np == 0
                #println("negative savings: ",k," ",is)
                Φp[np+1,1] += (Πz[is,1]/Πtot)*Φ[ki,is]  ##1st employed agent 
                Φp[np+1,2] += (Πz[is,2]/Πtot)*Φ[ki,is] #1st unemployed agent
            elseif np == DistributionSize
                #println("savings beyond grid: ",k," ",is)
                Φp[np,1] += (Πz[is,1]/Πtot)*Φ[ki,is]
                Φp[np,2] += (Πz[is,2]/Πtot)*Φ[ki,is]
            else
                # status is kp, employed
                ω = 1.0 - (kp-h1)/(h2-h1)
                Φp[np,1] += (Πz[is,1]/Πtot)*ω*Φ[ki,is]
                Φp[np+1,1] += (Πz[is,1]/Πtot)*(1.0 - ω)*Φ[ki,is]
                # status is kp, unemployed
                Φp[np,2] += (Πz[is,2]/Πtot)*ω*Φ[ki,is]
                Φp[np + 1,2] += (Πz[is,2]/Πtot)*(1.0 - ω)*Φ[ki,is]
            end
        end
    end

    #M = length(DistributionAssetGrid)
    #if statdist
    #    Φp = reshape(Φp,M*size(Πz,1))
    #    @show size(Φp)
    #    @show size(eye(M*size(Πz,1)))
    #    return statDist = (eye(M*size(Πz,1)) - Φp + ones(M*size(Πz,1),M*size(Πz,1)))'\ones(M*size(Πz,1))
    #else
    return Φp
    #end
end


function KSEquilibrium(FiniteElementObj::KSMarkovianFiniteElement{R,I}) where{R <: Real,I <: Integer,F <: Real}

    @unpack β,d,B_,γc,γl,α,ζ,homeY,hfix = FiniteElementObj.Parameters  
    @unpack elements,elementsID,zGrid,KGrid,nz,nK,ne = FiniteElementObj.FiniteElement  
    @unpack states,IndStates,AggStates,statesID,aggstatesID,ns,nis,nas,πz,Π,LoML =FiniteElementObj.MarkovChain 
    @unpack DistributionSize,DistributionAssetGrid,InitialDistribution,AggShocks,TimePeriods = FiniteElementObj.Distribution

    Rsqrd = fill(0.0, (2,))
    n_discard = 3000

    #Initial guess
    θ0 = FiniteElementObj.Guess
    LoMK = FiniteElementObj.LoMK
    
    #Initial distribution and average capital
    Φ = InitialDistribution
    for i = 1:100
        Ks = fill(0.0, (TimePeriods,))
        #@show 
        @show LoMK
        #solve individual problem
        θ0 = SolveFiniteElement(θ0,LoMK,KS)
        #Φ = NextPeriodDistribution(Φ,LoMK,AggShocks[1],AggShocks[1],θ0,FiniteElementObj,true)
        Ks[1] = sum(Φ[:,1] .* DistributionAssetGrid) + sum(Φ[:,2] .* DistributionAssetGrid)
        for t = 2:TimePeriods
            Φ = NextPeriodDistribution(Φ,LoMK,AggShocks[t-1],AggShocks[t],θ0,FiniteElementObj)
            Ks[t] = sum(Φ[:,1] .* DistributionAssetGrid) + sum(Φ[:,2] .* DistributionAssetGrid)
            #Ks[t] = K
        end

        ###Get indices of agg states
        n_g=count(i->(i==1),AggShocks[n_discard+1:end-1]) #size of data with good periods after discard
        n_b=count(i->(i==2),AggShocks[n_discard+1:end-1]) #size of data with bad periods after discard
        x_g=Vector{Float64}(n_g) #RHS of good productivity reression
        y_g=Vector{Float64}(n_g) #LHS of good productivity reression
        x_b=Vector{Float64}(n_b) #RHS of bad productivity reression
        y_b=Vector{Float64}(n_b) #LHS of bad productivity reression
        i_g=0
        i_b=0
        for t = n_discard+1:length(AggShocks)-1
            if AggShocks[t]==1
                i_g=i_g+1
                x_g[i_g]=log(Ks[t])
                y_g[i_g]=log(Ks[t+1])
            else
                i_b=i_b+1
                x_b[i_b]=log(Ks[t])
                y_b[i_b]=log(Ks[t+1])
            end
        end

        resg=lm(hcat(ones(n_g,1),x_g),y_g)
        resb=lm(hcat(ones(n_b,1),x_b),y_b)
        
        LoMKnew = fill(0.0,size(LoMK))
        @show Rsqrd[1]= r2(resg)
        @show Rsqrd[2]= r2(resb)
        @show LoMKnew[1,:] = coef(resg)
        @show LoMKnew[2,:] = coef(resb)
        #@show 
        if  LinearAlgebra.norm(LoMKnew - LoMK,Inf) < 0.000001
            println("Equilibrium found")
            return θ0, LoMK
            break
        else
            @show LoMK[1,:] = 0.5*LoMKnew[1,:] + 0.5*LoMK[1,:]
            @show LoMK[2,:] = 0.5*LoMKnew[2,:] + 0.5*LoMK[2,:]
        end
        println("LoM updated")
    end    
end


function Policies(
    kStream::Array{R,1},
    K::R,
    θ::Array{F,1},
    LoMK::Array{R,2},
    FiniteElementObj::KSMarkovianFiniteElement{R,I}) where{R <: Real,I <: Integer,F <: Real}

    @unpack β,d,B_,γc,γl,α,ζ,homeY,hfix = FiniteElementObj.Parameters  
    @unpack elements,elementsID,zGrid,KGrid,nz,nK,ne = FiniteElementObj.FiniteElement  
    @unpack states,IndStates,AggStates,statesID,aggstatesID,ns,nis,nas,πz,Π,LoML =FiniteElementObj.MarkovChain 

    #some helpful parameters
    nzK = nz*nK    

    #policies
    cPol = fill(0.0,(length(kStream),ns))
    kpPol = fill(0.0,(length(kStream),ns))
    


    nki=0
    n=0    
    for s = 1:ns
        A,ϵ = states[s,1],states[s,2]
        L = LoML[aggstatesID[s]] 
        Kb0,Kb1 = LoMK[aggstatesID[s],1], LoMK[aggstatesID[s],2]
        r = α*A*(K/L)^(α-1.0) - d 
        w = (1.0-α)*A*(K/L)^α
        for (ki,k) in enumerate(kStream)
            z = w*ϵ*hfix + homeY*(1.0 - ϵ) + (1.0 + r)*k - r*B_
            for i = 1:ne
                if (z>=elements[i,1] && z<=elements[i,2]) 
                    nki = i     
                    break
                elseif z<elements[1,1]
                    nki = 1
                    break
                else
                    nki = ne-nz
                end
            end
            # Find the aggregate state and adjust if it falls outside the grid
            for j = nki:nki+nK-2
                if (K >= elements[j,3] && K <= elements[j,4]) 
                    n = j     
                    break
                elseif K < elements[nki,3]
                    n = nki
                    break
                else
                    n = nki+nK-2
                end
            end

            z1,z2 = elements[n,1],elements[n,2]
            K1,K2 = elements[n,3],elements[n,4]
            zii,Ki = elementsID[n,1],elementsID[n,3] #indices of endog states for policy
            s1,s4 = (s-1)*nzK + (zii-1)*nK + Ki, (s-1)*nzK + (zii-1)*nK + Ki + 1
            s2,s3 = (s-1)*nzK + zii*nK + Ki, (s-1)*nzK + zii*nK + Ki + 1

            basis1 = (z2 - z)/(z2 - z1) * (K2 - K)/(K2 - K1)
            basis2 = (z - z1)/(z2 - z1) * (K2 - K)/(K2 - K1)
            basis3 = (z - z1)/(z2 - z1) * (K - K1)/(K2 - K1)
            basis4 = (z2 - z)/(z2 - z1) * (K - K1)/(K2 - K1)

            #Policy functions 
            kp = θ[s1]*basis1 + θ[s2]*basis2 + θ[s3]*basis3 + θ[s4]*basis4

            cPol[ki,s] = z - kp
            kpPol[ki,s] = kp
            if kp < k && (s == 1 || s == 3)
                println("disavings at k = ",k," ",s)
            end
        end
    end
  
    return cPol,kpPol
end

KS = KSModel()
LoMK = KS.LoMK
Guess = KS.Guess

pol = SolveFiniteElement(Guess,LoMK,KS)
kStream = collect(range(0.0, stop=400.0, length=1000))
polc,polkp  = Policies(kStream,10.5,pol,LoMK,KS)
p = plot(kStream,polkp[:,1], label = "High productivity employed")
p = plot!(kStream,polkp[:,2], label = "High productivity unemployed")
p = plot!(kStream,polkp[:,3], label = "Low productivity employed")
p = plot!(kStream,polkp[:,4], label = "Low productivity unemployed")
p = plot!(kStream,kStream, line = :dot, label = "45 degree line")
p = plot!(label=:topleft)
p = plot!(xlims = (0.0,5.0), ylims=(0.0,5.0))

#KS2 = KSModel(1.5,2.5,0.25,0.04,0.1,8.0,8.0,30,50.0,9,9.0,8.0,0.98,0.025,1.0,1.0,1.0,0.36,1.0,100.0,0.0,0.135,0.93,0.135,0.93,300,10000,30.0,2)
#LoMK = KS2.LoMK
#Guess = KS2.Guess
#pol2 = SolveFiniteElement(Guess,LoMK,KS2)        
#polc2,polkp2  = Policies(kStream,8.5,pol2,LoMK,KS2)
#p = plot!(kStream,polkp2[:,2], label = "High productivity employed")
#p = plot!(linewidth=0.002)
#p2 = plot!(kStream,polkp[:,2], label = "High productivity unemployed")
#p2 = plot!(kStream,polkp[:,3], label = "Low productivity employed")
#p2 = plot!(kStream,polkp[:,4], label = "Low productivity unemployed")
#p2 = plot!(kStream,kStream, line = :dot, label = "45 degree line")
#p = plot!(xlims = (0.0,0.2), ylims=(0.0,0.2))




savefig(p,"Policies.pdf")
#@show LinearAlgebra.norm(polkp1-polkp2)


#SolveFiniteElement(KS.Guess,KS.LoMK,KS)
#Guess,GuessM = KS.Guess,KS.GuessM        
#pol = SolveFiniteElement(Guess,LoMK,KS)        
##elements,elementsID,kGrid,KGrid,m,wx,ax,nk,nK,ne 
#@unpack elements,elementsID,zGrid,KGrid,m,wx,ax,nk,nK,ne = KS.FiniteElement
#@unpack states,statesID,aggstatesID,ns,πz,Π,LoML = KS.MarkovChain
#p = plot(zGrid,GuessM[collect(1:nK:nk*nK),1], label = "employed")
#p = plot!(zGrid,GuessM[collect(1:nK:nk*nK),2], label = "unemployed")
#p = plot!(zGrid,kGrid, line = :dot, label = "45 degree line")
#p = plot!(xlims = (0.0,5.0), ylims=(0.0,5.0))
#savefig(p,"Exolaborguess.pdf")


pol, LoMK = KSEquilibrium(KS)
KS = KSModel()
@unpack elements,elementsID,zGrid,KGrid,m,wx,ax,nz,nK,ne = KS.FiniteElement
@unpack states,statesID,aggstatesID,ns,πz,Π,LoML = KS.MarkovChain
aGrid = collect(range(0.0,stop = zGrid[end],length = length(zGrid)))
Guess = KS.Guess
LoMK = KS.LoMK
#pol = SolveFiniteElement(Guess,LoMK,KS)
polr = reshape(pol,nK,nz,ns)
p1 = plot(zGrid,polr[1,:,1], label = "employed good",linewidth = 0.2)
p1 = plot!(zGrid,polr[1,:,2], label = "unemployed good",linewidth = 0.2)
#p1 = plot!(linewidth = 5)
#p1 = plot!(zGrid,polr[1,:,3], label = "employed bad")
#p1 = plot!(zGrid,polr[1,:,4], label = "unemployed bad")
p1 = plot!(aGrid,aGrid, line = :dot, label = "45 degree line")
p1 = plot!(title = "Low Aggregate Capital")
p2 = plot(zGrid,polr[2,:,1], label = "employed good",linewidth = 0.2)
p2 = plot!(zGrid,polr[2,:,2], label = "unemployed good",linewidth = 0.2)
#p2 = plot!(zGrid,polr[2,:,3], label = "employed bad")
#p2 = plot!(zGrid,polr[2,:,4], label = "unemployed bad")
p2 = plot!(aGrid,aGrid, line = :dot, label = "45 degree line")
p2 = plot!(title = "Middle Aggregate Capital")
p3 = plot(zGrid,polr[3,:,1], label = "employed good",linewidth = 0.2)
p3 = plot!(zGrid,polr[3,:,2], label = "unemployed good",linewidth=0.2)
#p3 = plot!(zGrid,polr[3,:,3], label = "employed bad")
#p3 = plot!(zGrid,polr[3,:,4], label = "unemployed bad")
p3 = plot!(aGrid,aGrid, line = :dot, label = "45 degree line")
p3 = plot!(title = "High Aggregate Capital")
p = plot(p1,p2,p3, layout = (1,3))
p = plot!(xlims = (0.0,300.0), ylims=(0.0,300.0), size=(1000,300))
p = plot!(legendfont = font(4,"courier"))
p = plot!(titlefont = font(6,"courier"))
p = plot!(linewidth = 1)
p = plot!(legend=:topleft)
savefig(p,"ExolaborSol.pdf")

#@btime NextPeriodDistribution(Prob0,LoMK,1,2,pol,KS)
@unpack DistributionSize,DistributionAssetGrid,InitialDistribution,AggShocks,TimePeriods = KS.Distribution
#prob = NextPeriodDistribution(InitialDistribution,LoMK,1,2,pol,KS)
#p = plot(DistributionAssetGrid,prob[1:DistributionSize], label="employed")
#p = plot!(DistributionAssetGrid,prob[DistributionSize+1:2*DistributionSize], label="unemployed")
#savefig(p,"distribution.pdf")
#jacobian = WeightedResidual(Guess,KS)[2]
#jacobian2 = ForwardDiff.jacobian(x -> WeightedResidual(x,KS)[1],Guess)
#@show LinearAlgebra.norm(jacobian - jacobian2,Inf)


#Prob0 = NextPeriodDistribution(Prob0,LoMK,1,2,pol,KS)




Prob = NextPeriodDistribution(InitialDistribution,LoMK,1,2,pol,KS,true)
p = plot(DistributionAssetGrid[1:end],Prob[:,1] + Prob[:,2], label = "9000 periods")
savefig(p,"distribution.pdf")


Prob0 = InitialDistribution
p = plot(title= "Distribution")
for i = 1:9001   
    Prob0 = NextPeriodDistribution(Prob0,LoMK,AggShocks[i],AggShocks[i+1],pol,KS)
    if i == 100
        p = plot!(DistributionAssetGrid[1:end],Prob0[:,1] + Prob0[:,2], label = "100 periods")
    elseif i==200
        p = plot!(DistributionAssetGrid[1:end],Prob0[:,1] + Prob0[:,2], label = "200 periods")
    elseif i==500
        p = plot!(DistributionAssetGrid[1:end],Prob0[:,1] + Prob0[:,2], label = "500 periods")
    elseif i==1000
        p = plot!(DistributionAssetGrid[1:end],Prob0[:,1] + Prob0[:,2], label = "1000 periods")
    elseif i==9000
        p = plot!(DistributionAssetGrid[1:end],Prob0[:,1] + Prob0[:,2], label = "9000 periods")
    end
end
p = plot!(xlims = (0.0,30.0))
savefig(p,"distribution.pdf")



