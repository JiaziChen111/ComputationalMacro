using LinearAlgebra
using Parameters
using IterativeSolvers
using Plots
using BenchmarkTools
using FastGaussQuadrature
using BenchmarkTools
using ForwardDiff
using QuantEcon
using GLM
################################### Model types #########################

struct ModelParametersEnd{R <: Real}
    β::R
    d::R
    B_::R
    γ::R
    σ::R
    α::R
    ζ::R
    homeY::R
end

struct ModelFiniteElementEnd{R <: Real,I <: Integer}
    elements::Array{R,2}
    elementsID::Array{I,2}
    zGrid::Array{R,1}
    KGrid::Array{R,1}
    m::I
    wx::Array{R,1}
    ax::Array{R,1}
    nz::I
    nK::I
    ne::I
end

struct ModelMarkovChainEnd{R <: Real,I <: Integer}
    states::Array{R,2}
    statesID::Array{I,2}
    aggstatesID::Array{I,1}
    ns::I
    nis::I
    nas::I
    πz::Array{R,2} #aggregate transition
    Π::Array{R,2}
    IndStates::Array{R,1}
    AggStates::Array{R,1}
end

struct ModelDistributionEnd{R <: Real,I <: Integer}
    DistributionSize::I
    DistributionAssetGrid::Array{R,1}
    InitialDistribution::Array{R,2}
    AggShocks::Array{I,1}
    TimePeriods::I
end


struct KSMarkovFiniteElementEnd{R <: Real,I <: Integer}
    Guess::Array{R,1}
    GuessM::Array{R,3}
    LoMK::Array{R,1}
    LoML::Array{R,1}
    Parameters::ModelParametersEnd{R}
    FiniteElement::ModelFiniteElementEnd{R,I}
    MarkovChain::ModelMarkovChainEnd{R,I}
    Distribution::ModelDistributionEnd{R,I}
end


#Include ayiagari functions and types
#include("ks.jl")

"""
Construct and Ayiagari model instace of all parts needed to solve the model
"""
function KSModelEnd(
    UnempDurG::R = 1.5,
    UnempDurB::R = 2.5,
    Corr::R = 0.25,
    UnempG::R = 0.04,
    UnempB::R = 0.1,
    DurZG::R = 8.0,
    DurZB::R = 8.0,
    nz::I = 30, #asset grid size
    zMax::R = 90.0, #uppper bound on capital
    nK::I = 5, #aggregate capital grid size
    KMax::R = 13.0, #upper bound on aggregate capital
    KMin::R = 10.5,
    gZ::R = 1.01,
    bZ::R = 0.99,
    empS::R = 1.0,
    unempS::R = 0.0,
    β::R = 0.99,
    d::R = 0.025,
    B_::R = 0.0,
    γ::R = 1.0/2.9,
    σ::R = 1.0,
    α::R = 0.36,
    ζ::R = 10000.0,
    homeY::R = 0.07,
    Kg1::R =0.12,
    Kg2::R =0.96,
    Kb1::R =0.11,
    Kb2::R =0.96,
    Lg1::R =-0.54,
    Lg2::R =-0.25,
    Lb1::R =-0.59,
    Lb2::R =-0.26,
    NumberOfHouseholds::I = 700,
    TimePeriods::I = 8000,
    DistributionUL::R = 90.0,
    NumberOfQuadratureNodesPerElement::I = 2
) where{R <: Real,I <: Integer}


    ###################################################
    ################   Stochastic process #############
    ###################################################
    # unemployment rates depend only on the aggregate productivity shock
    Unemp = [UnempG;UnempB]
    
    # probability of remaining in 'Good/High' productivity state
    πzg = 1.0 - 1.0/DurZG
    
    # probability of remaining in the 'Bad/Low' productivity state
    πzb = 1.0 - 1.0/DurZB
    
    # matrix of transition probabilities for aggregate state
    πz = [πzg 1.0-πzg;
          1.0-πzb πzb]
    
    # transition probabilities between employment states when aggregate productivity is high
    p22 = 1.0 - 1.0 / UnempDurG
    p21 = 1.0 - p22
    p11 = (((1.0 - UnempG) - UnempG * p21) / (1.0 - UnempG))
    #       e    u   for good to good
    P11 = [p11 1.0-p11; 
           p21 p22]
    
    # transition probabilities between employment states when aggregate productivity is low
    p22 = 1.0 - 1.0 / UnempDurB
    p21 = 1.0 - p22
    p11 = (((1.0 - UnempB) - UnempB * p21) / (1.0 - UnempB))
    #       e    u   for bad to bad
    P00 = [p11 1.0-p11; 
           p21 p22] 
    
    # transition probabilities between employment states when aggregate productivity is high
    p22 = (1.0 + Corr) * p22
    p21 = 1.0 - p22
    p11 = (((1.0 - UnempB) - UnempG * p21) / 
           (1.0 - UnempG))
    #       e    u   for good to bad
    P10 = [p11 1.0-p11; 
           p21 p22]

    p22 = (1.0 - Corr) * (1.0 - 1.0 / UnempDurG)
    p21 = 1.0 - p22
    p11 = (((1.0 - UnempG) - UnempB * p21) / 
           (1.0 - UnempB))
    #       e    u   for bad to good
    P01 = [p11 1.0-p11; 
           p21 p22]

    P = [πz[1,1]*P11 πz[1,2]*P10;
         πz[2,1]*P01 πz[2,2]*P00]
    
    states = [gZ empS;gZ unempS;bZ empS;bZ unempS] 
    statesID = [1 1;1 2;2 1; 2 2]
    aggstatesID = [1;1;2;2]
    ns = size(states,1)

    LoMK = [Kg1;Kg2;Kb1;Kb2]
    LoML = [Lg1;Lg2;Lb1;Lb2]

    nis = 2 #number of individual states
    nas = 2 #number of aggregate states
    KSMarkovChain =ModelMarkovChainEnd(states,statesID,aggstatesID,ns,nis,nas,πz,P,[empS;unempS],[gZ;bZ])    

    ##########################################################
    ############### Mesh generation ##########################
    ##########################################################
    function grid_fun(a_min,a_max,na, pexp)
        x = range(a_min,step=0.5,length=na)
        grid = a_min .+ (a_max-a_min)*(x.^pexp/maximum(x.^pexp))
        return grid
    end
    #kGrid = grid_fun(0.0,kMax,nk,4.0)
    zGrid = collect(linspace(homeY^(1/30), zMax^(1/30), nz).^30)
    KGrid = collect(range(KMin,stop = KMax,length=nK))
    #LGrid = range(LMin,stop = LMax,length=nL)
    nzK = nz*nK

    ne = (nz-1)*(nK-1)               #number of elements
    nv = 4                                   #number of values by element (k1,k2,K1,K2,L1,L2)
    
    ElementsID = zeros(I,ne,nv) #element indices
    Elements = zeros(R,ne,nv) #elements

    #Build finite element mesh with node indices (k1,k2,K1,K2,L1,L2) per element
    #Build finite element mesh with node indices (k1,k2,K1,K2,L1,L2) per element
    for zi = 1:nz-1 #across ind k
        for Ki = 1:nK-1 #across agg L
            n = (zi-1)*(nK-1) + Ki  
            ElementsID[n,1],ElementsID[n,2] = zi,zi+1
            ElementsID[n,3],ElementsID[n,4] = Ki,Ki+1
            Elements[n,1],Elements[n,2] = zGrid[zi],zGrid[zi+1]
            Elements[n,3],Elements[n,4] = KGrid[Ki],KGrid[Ki+1]
        end
    end
    QuadratureAbscissas,QuadratureWeights = gausslegendre(NumberOfQuadratureNodesPerElement)
    KSFiniteElement = ModelFiniteElementEnd(Elements,ElementsID,zGrid,KGrid,NumberOfQuadratureNodesPerElement,QuadratureWeights,QuadratureAbscissas,nz,nK,ne)
    #KSFiniteElement = ModelFiniteElementEnd(Elements,ElementsID,kGrid,KGrid,NumberOfQuadratureNodesPerElement,QuadratureWeights,QuadratureAbscissas,nk,nK,ne)

    #return KSMC, Elements, ElementID
    Guess = zeros(R,nkK*ns)
    #GuessPolicy = zeros(nkKL*ns)

    #@show nkKL*ns
    #solution guess θ for a(k,k̄;θs) at each node on the grid of x
    Guess = zeros(R,nzK*ns)
    for s=1:ns
        A,ϵ = states[s,1],states[s,2]
        for (zi,z) in enumerate(zGrid) #ind k
            for (Ki,K) in enumerate(KGrid) #agg k
                n = (s-1)*nzK + (zi-1)*nK + Ki
                Guess[n] = 0.98*z  
            end
        end
    end
    GuessM = reshape(Guess,nzK,ns)

    #=for s=1:ns
        z,ϵ = states[s,1],states[2,2]
        Lb0,Lb1 = LoML[nas*(aggstatesID[s]-1)+1], LoML[nas*(aggstatesID[s]-1)+2]
        Kb0,Kb1 = LoMK[nas*(aggstatesID[s]-1)+1], LoMK[nas*(aggstatesID[s]-1)+2] 
        for (ki,k) in enumerate(kGrid) #ind k
            for (Ki,K) in enumerate(KGrid) #agg k
                ##forecast labor
                L = exp(Lb0 + Lb1*log(K))
                n = (s-1)*nkK + (ki-1)*nK + Ki
                r = α*z*K^(α-1.0)*L^(1.0-α)-d
                w = (1.0-α)*z*K^(α)*L^(-α)
                l = 0.5
                (s == 1 || s == 3) ? c = 0.9 : c = 0.3
                kp = (1.0 + r)*k + w*(1.0 - l)*ϵ + (1.0 - ϵ)*homeY - c
                for j = 1:100 
                    c = (1.0 + r)*k + ϵ*w*(1.0 - l) + (1.0 - ϵ)*homeY - kp
                    ∂c∂l = -ϵ*w
                    ul = (1.0-γ)/γ*1.0/l
                    ull = -1.0*((1.0-γ)/γ)*1.0/l^2.0
                    uc = 1.0/c
                    ucc = -1.0/c^2.0                    
                    mrs = -ul + w*ϵ*uc + ζ*min(1.0 - l,0.0)^2
                    dmrs = -ull + w*ϵ*ucc*∂c∂l - 2.0*ζ*min(1.0 - l,0.0)
                    l += -1.0* mrs/dmrs
                    if abs(mrs/dmrs) < 1e-14
                        break
                    elseif j == 100
                        error("Did not converge")
                    end
                end
                if c < 0.0
                    println(s," ",k)
                end
                Guess[n] = 0.98*kp
            end
        end
    end
    GuessM = reshape(Guess,nK,nk,ns) =#

    ################### Distribution pieces
    DistributionAssetGrid = collect(range(kGrid[1],stop = DistributionUL,length = NumberOfHouseholds))
    InitialDistribution = rand(nis*NumberOfHouseholds)
    InitialDistribution = InitialDistribution/sum(InitialDistribution)
    InitialDistribution = reshape(InitialDistribution,NumberOfHouseholds,nis)

    mc = MarkovChain(πz, [1, 2])
    AggShocks = simulate(mc,TimePeriods,init=1)

    KSDistribution = ModelDistributionEnd(NumberOfHouseholds,DistributionAssetGrid,InitialDistribution,AggShocks,TimePeriods)

    KSParameters = ModelParametersEnd(β,d,B_,γ,σ,α,ζ,homeY)
    
    KSMarkovFiniteElementEnd(Guess,GuessM,LoMK,LoML,KSParameters,KSFiniteElement,KSMarkovChain,KSDistribution)
end

KS = KSModelEnd()
