using LinearAlgebra
using Parameters
using IterativeSolvers
################################### Model types #########################

mutable struct ModelParameters{R <: Real}
    β::R
    α::R
    δ::R
    μ::R
    σ::R
    ρ::R
    ζ::R
    Uc::Function
    Ucc::Function
end

struct FiniteElementSolution{R <: Real}
    Nodes::Array{R,1}
    Solutions::Array{R,1}
end

struct MarkovianFiniteElement{R <: Real,I <: Integer}
    Nodes::Array{R,1}
    Elements::Array{R,2} 
    CoefficientIndices::Array{I,2}
    TransitionMatrix::Array{R,2}
    IndividualStates::Array{R,1}
    Guess::Array{R,1}
    GuessMatrix::Array{R,2}
    NumberOfNodes::Int64
    NumberOfIndividualStates::Int64
    NumberOfElements::Int64
    NumberOfQuadratureNodesPerElement::Int64
    Parameters::ModelParameters{R}
    QuadratureWeights::Array{R,1}
    QuadratureAbscissas::Array{R,1}
    ResidualJacobian0::Array{R,2}
    Residual0::Array{R,1}
    DistributionSize::Int64
    DistributionAssetGrid::Array{R,1}
end

"""
Inputs:
nodes: grid on assets
prices: interest rate
Π: transition probability

Output:
θ: solution to the finite element method after imposing boundary conditions

Description:
The main loop has 2 steps:
In the first step, if computes the FEM solution without any boundary conditions
In the second step, we use the 'kink' array of indices to impose the boundary conditions

The weighted residual equation and its jacobian

inputs:
m: quad nodes for integration
ns: number of stochastic states
na: grid size on assets

"""
function WeightedResidual(
    θ::Array{R,1},
    InterestRate::R,
    FiniteElementObj::MarkovianFiniteElement{R,I}) where{R <: Real,I <: Integer}
    
    #Model parameters
    @unpack β,α,δ,μ,σ,ρ,ζ,Uc,Ucc = FiniteElementObj.Parameters
    
    #Finite element object
    nodes = FiniteElementObj.Nodes
    Π = FiniteElementObj.TransitionMatrix
    states = FiniteElementObj.IndividualStates
    na = FiniteElementObj.NumberOfNodes
    ns = FiniteElementObj.NumberOfIndividualStates
    ne = FiniteElementObj.NumberOfElements
    m = FiniteElementObj.NumberOfQuadratureNodesPerElement
    nx = na*ns
    
    ax,wx = FiniteElementObj.QuadratureAbscissas,FiniteElementObj.QuadratureWeights
    
    #model FiniteElementObj.Parameters
    r = InterestRate
    w = (1.0 - α)*(α/(r+δ))^(α/(1.0 - α))
    
    dResidual = copy(FiniteElementObj.ResidualJacobian0)
    Residual = copy(FiniteElementObj.Residual0)
    np = 0    
    for s = 1:ns
        l = states[s]
        for n=1:ne
            s1 = (s-1)*na + n
            s2 = (s-1)*na + n + 1
            a1,a2 = nodes[n],nodes[n+1]
            for i=1:m
                #transforming k according to Legendre's rule
                x = (a1 + a2)/2.0 + (a2 - a1)/2.0 * ax[i]
                v = (a2-a1)/2.0*wx[i]

                #Form basis for piecewise function
                basis1 = (a2 - x)/(a2 - a1)
                basis2 = (x - a1)/(a2 - a1)

                #Policy functions
                a = θ[s1]*basis1 + θ[s2]*basis2
                c = (1.0 + r)*x + w*l - a

                #agents characteristics
                u  = (c^(1.0 - μ) - 1.0)/(1.0 - μ)
                pen = min(a,0.0)^2
                dpen = 2*min(a,0.0)
                uc  = c^(-μ)
                ucc = -μ*c^(-μ-1.0) 
                ∂c∂ai = -1.0

                xp = a
                np = searchsortedlast(nodes,xp)

                ##Adjust indices if assets fall out of bounds
                (np > 0 && np < na) ? np = np : 
                    (np == na) ? np = na-1 : 
                        np = 1 

                ap1,ap2 = nodes[np],nodes[np+1]
                basisp1 = (ap2 - xp)/(ap2 - ap1)
                basisp2 = (xp - ap1)/(ap2 - ap1)

                ####### Store derivatives###############
                #basis (derivative of c(kp,θ) wrt kp)
                dbasisp1 = -1.0/(ap2 - ap1)
                dbasisp2 = -dbasisp1

                
                tsai = 0.0
                sum1 = 0.0
                for sp = 1:ns
                    sp1 = (sp-1)*na + np
                    sp2 = (sp-1)*na + np + 1
                    lp = states[sp]

                    #Policy functions
                    ap = θ[sp1]*basisp1 + θ[sp2]*basisp2
                    cp = (1.0 + r)*xp + w*lp - ap

                    #agents characteristics
                    up  = (cp^(1.0 - μ) - 1.0)/(1.0 - μ)
                    ucp  = cp^(-μ)
                    uccp = -μ*cp^(-μ - 1.0)

                    ∂ap∂xp = θ[sp1]*dbasisp1 + θ[sp2]*dbasisp2
                    ∂xp∂ai = (1.0 + r)
                    ∂cp∂ai = ∂xp∂ai - ∂ap∂xp 
                    ∂cp∂aj = -1.0

                    sum1 += β*(Π[s,sp]*(1.0 + r)*ucp + ζ*pen) 

                    #summing derivatives with respect to θs_i associated with c(s)
                    tsai += β*(Π[s,sp]*(1.0 + r)*uccp*∂cp∂ai + ζ*dpen)                                
                    tsaj = β*Π[s,sp]*(1.0 + r)*uccp*∂cp∂aj

                    dResidual[s1,sp1] +=  basis1 * v * tsaj * basisp1
                    dResidual[s1,sp2] +=  basis1 * v * tsaj * basisp2
                    dResidual[s2,sp1] +=  basis2 * v * tsaj * basisp1
                    dResidual[s2,sp2] +=  basis2 * v * tsaj * basisp2
                end
                
                ##add the LHS and RHS of euler for each s wrt to θi
                dres =  tsai - ucc*∂c∂ai 
                
                dResidual[s1,s1]+=  basis1 * v * dres * basis1
                dResidual[s1,s2]+=  basis1 * v * dres * basis2
                dResidual[s2,s1]+=  basis2 * v * dres * basis1
                dResidual[s2,s2]+=  basis2 * v * dres * basis2
                
                res = sum1 - uc
                Residual[s1] += basis1*v*res
                Residual[s2] += basis2*v*res  
            end
        end
    end 
   Residual,dResidual 
end


function SolveFiniteElement(
    InterestRate::R,
    guess::Array{R,1},
    FiniteElementObj::MarkovianFiniteElement{R,I},
    maxn::Int64 = 200,
    tol = 1e-8
) where{R <: Real,I <: Integer}

    θ = guess
    #Newton Iteration
    for i = 1:maxn
        Res,dRes = WeightedResidual(θ,InterestRate,FiniteElementObj)
        step = -1.0/1.0* dRes \ Res 
        θ += step
        if LinearAlgebra.norm(step) < tol
            println("number of newton steps: ",i)
            return θ
            break
        end
    end
        
    return println("Did not converge")
end


function StationaryDistribution(
    InterestRate::R,
    θ::Array{R,1},
    FiniteElementObj::MarkovianFiniteElement{R,I}
) where{R <: Real,I <: Integer}
    
    @unpack β,α,δ,μ,σ,ρ,ζ = FiniteElementObj.Parameters
    nodes = FiniteElementObj.Nodes
    Π = FiniteElementObj.TransitionMatrix
    states = FiniteElementObj.IndividualStates
    na = FiniteElementObj.NumberOfNodes
    ns = FiniteElementObj.NumberOfIndividualStates
    
    res = collect(range(nodes[1],stop = nodes[end],length = NumberOfHouseholds))
    nf = ns*FiniteElementObj.DistributionSize
    r = InterestRate
    w = (1.0 - α)*(α/(r+δ))^(α/(1.0 - α))
    θ = reshape(θ,na,ns)
    
    ##initialize
    pdf1 = zeros(NumberOfHouseholds,ns)
    Qa = zeros(nf,nf)
    c,ap =zeros(NumberOfHouseholds,ns),zeros(NumberOfHouseholds,ns)
    
    
    
    for s=1:ns
        for i=1:NumberOfHouseholds
            x = res[i] 
            
            ######
            # find each k in dist grid in nodes to use FEM solution
            ######
            n = searchsortedlast(nodes,x)
            (n > 0 && n < na) ? n = n : 
                (n == na) ? n = na-1 : 
                    n = 1 
            x1,x2 = nodes[n],nodes[n+1]
            basis1 = (x2 - x)/(x2 - x1)
            basis2 = (x - x1)/(x2 - x1)
            ap[i,s]  = basis1*θ[n,s] + basis2*θ[n+1,s]
            #c[i,s] = (1.0+r)*x + w*states[s] - ap[i,s] 
            #z[i,s] = (1.0+r)*x + w*states[s]
            
            
            ######
            # Find in dist grid where policy function is
            ######            
            n = searchsortedlast(res,ap[i,s])
            
            ######
            # Build histogram
            ######            
            for si = 1:ns
                aa = (s-1)*NumberOfHouseholds + i
                ss = (si-1)*NumberOfHouseholds + n
                if n > 0 && n < NumberOfHouseholds
                    ω = 1.0 - (ap[i,s] - res[n])/(res[n+1] - res[n])
                    Qa[aa,ss+1] += Π[s,si]*ω
                    Qa[aa,ss]  += Π[s,si]*(1.0 - ω)
                elseif n == 0
                    ω = 1.0
                    Qa[aa,ss+1] += Π[s,si]*ω
                else
                    ω = 1.0
                    Qa[aa,ss] += Π[s,si]*ω
                end
            end
        end
    end

    for i = 1:nf
        for j = 1:nf
            (Qa[i,j] == 0.0) ? Qa[i,j] = 0.000000001 : Qa[i,j] = Qa[i,j]
        end
    end
            
        
    
    #Get the eigen vector of unity eigenvalue by power method
    λ, x = powm!(transpose(Qa), rand(nf), maxiter = 1000,tol = 1e-10)
    
    #renormalize eigen vector so it adds up to one by state
    for i = 1:nf
        pdf1[i] = 1.0/sum(x) * x[i]
    end

    EA = 0.0
    for s = 1:ns
        for ki = 1:NumberOfHouseholds
            #i = (s-1)*NumberOfHouseholds + ki
            EA += pdf1[ki,s]*res[ki]            
        end
    end

    res,EA,pdf1
end


function equilibrium(
    FiniteElementObj::MarkovianFiniteElement{R,I},
    tol = 1e-10,maxn = 100
) where{R <: Real,I <: Integer}
    
    @unpack β,α,δ,μ,σ,ρ,ζ = FiniteElementObj.Parameters
    #nodes = FiniteElementObj.Nodes
    #Π = FiniteElementObj.TransitionMatrix
    #states = FiniteElementObj.IndividualStates
    na = FiniteElementObj.NumberOfNodes
    #ns = FiniteElementObj.NumberOfIndividualStates
    nx,ns = 20,FiniteElementObj.NumberOfIndividualStates
    
    #Bisection method for equilibrium
    cm_ir = (1.0/β-1.0) #complete markets interest rate

    Demand = zeros(nx)
    Supply = zeros(nx)
    θ_eq = zeros(ns*na) 
    cap_eq = 0.0
    EA = 0.0
    #_,EA,_ = StationaryDistribution(r0,θ_eq,DistributionSize)
    Residual, dResidual = zeros(na*ns), zeros(na*ns,na*ns)
    
    ###Start Bisection
    r0 = 0.98 * cm_ir
    up_ir,low_ir = cm_ir,-δ #upper and lower bound on bisection
    θ_eq = FiniteElementObj.Guess
    for i = 1:maxn
        dResidual .= 0.0
        Residual .= 0.0        
        θ_eq = SolveFiniteElement(r0,θ_eq,FiniteElementObj)
        _,EA,_ = StationaryDistribution(r0,θ_eq,FiniteElementObj)
        
        ### Implicit interest rate along
        rd = α*EA^(α - 1.0) - δ
                
        
        ### narrow interval by updating upper and lower bounds on 
        ### interval to search new root
        if (rd > r0)
             r = 1.0/2.0*(min(up_ir,rd) + max(low_ir,r0))
             up_ir = min(up_ir,rd)
             low_ir = max(low_ir,r0)
        else
             r = 1.0/2.0*(min(up_ir,r0) + max(low_ir,rd))
             low_ir = max(low_ir,rd)
             up_ir = min(up_ir,r0)
        end
        
        println("ir: ",r0," supply ",EA," demand ",((r0 + δ)/α)^(1.0/(α - 1.)))
        if abs(r - r0) < 0.0000000000001
            cap_eq = EA
            r0 = r
            break
        end
        r0 = r
    end 
    
    return r0,θ_eq,cap_eq 
end 

function PlotEquilibrium(
    EquilibriumIR::R,
    FiniteElementObj::MarkovianFiniteElement{R,I}
) where{R <: Real,I <: Integer}

    @unpack β,α,δ,μ,σ,ρ,ζ = FiniteElementObj.Parameters
    nx = 30
    Supply = zeros(nx)
    Demand = zeros(nx)
    θ0 = FiniteElementObj.Guess
    #Get a sequence of asset demand and supply for display
    ir  = collect(range(0.7*EquilibriumIR,stop=1.3*EquilibriumIR,length=nx))
    for i = 1:nx
        r = ir[i]
        θ0 =  SolveFiniteElement(r,θ0,FiniteElementObj)
        _,EA,_ = StationaryDistribution(r,θ0,FiniteElementObj)
        Supply[i] = EA
        Demand[i] = ((r + δ)/α)^(1.0/(α - 1.0))
    end

    return Demand,Supply
end
    
